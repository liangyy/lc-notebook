<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Need to Know on LeetCode NoteBook</title>
    <link>https://liangyy.github.io/lc-notebook/needtoknow/</link>
    <description>Recent content in Need to Know on LeetCode NoteBook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://liangyy.github.io/lc-notebook/needtoknow/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Q218. The Skyline Problem</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q218/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q218/</guid>
      <description>A city&#39;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). Buildings Skyline Contour The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height.</description>
    </item>
    
    <item>
      <title>Q47. Permutations II</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q47/</link>
      <pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q47/</guid>
      <description>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Constraints: 1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 This question is not super tricky to solve but it does need a thorough thought of the problem. I will state what I originally have and what is actually the nice solution of the problem.</description>
    </item>
    
    <item>
      <title>Q1283. Find the Smallest Divisor Given a Threshold</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q1283/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q1283/</guid>
      <description>Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).</description>
    </item>
    
    <item>
      <title>Q310. Minimum Height Trees</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q310/</link>
      <pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q310/</guid>
      <description>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.</description>
    </item>
    
    <item>
      <title>Q673. Number of Longest Increasing Subsequence</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q673/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q673/</guid>
      <description>Given an integer array nums, return the number of longest increasing subsequences. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&#39; length is 1, so output 5. Constraints: 0 &amp;lt;= nums.length &amp;lt;= 2000 -106 &amp;lt;= nums[i] &amp;lt;= 106 For this question, my first thought is dynamic programming.</description>
    </item>
    
    <item>
      <title>Q99. Recover Binary Search Tree</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q99/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q99/</guid>
      <description>You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 &amp;gt; 1. Swapping 1 and 3 makes the BST valid.</description>
    </item>
    
    <item>
      <title>Q316. Remove Duplicate Letters</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q316/</link>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q316/</guid>
      <description>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/ Example 1: Input: s = &amp;quot;bcabc&amp;quot; Output: &amp;quot;abc&amp;quot; Example 2: Input: s = &amp;quot;cbacdcbc&amp;quot; Output: &amp;quot;acdb&amp;quot; Constraints: 1 &amp;lt;= s.length &amp;lt;= 104 s consists of lowercase English letters. I think this question definitely fits into &amp;ldquo;Need to Know&amp;rdquo; category.</description>
    </item>
    
    <item>
      <title>Q459. Repeated Substring Pattern</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q459/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q459/</guid>
      <description>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1: Input: &amp;quot;abab&amp;quot; Output: True Explanation: It&#39;s the substring &amp;quot;ab&amp;quot; twice. Example 2: Input: &amp;quot;aba&amp;quot; Output: False Example 3: Input: &amp;quot;abcabcabcabc&amp;quot; Output: True Explanation: It&#39;s the substring &amp;quot;abc&amp;quot; four times.</description>
    </item>
    
    <item>
      <title>Q600: Non-negative Integers without Consecutive Ones</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q600/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q600/</guid>
      <description>Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation: Here are the non-negative integers &amp;lt;= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.</description>
    </item>
    
    <item>
      <title>Q847. Shortest Path Visiting All Nodes</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q847/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q847/</guid>
      <description>An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</description>
    </item>
    
    <item>
      <title>Q309: Best Time to Buy and Sell Stock with Cooldown</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q309/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q309/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>Q307. Range Sum Query - Mutable</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q307/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q307/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Q94. Binary Tree Inorder Traversal</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q94/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
