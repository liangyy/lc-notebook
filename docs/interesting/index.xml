<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interesting on LeetCode NoteBook</title>
    <link>https://liangyy.github.io/lc-notebook/interesting/</link>
    <description>Recent content in Interesting on LeetCode NoteBook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 09 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://liangyy.github.io/lc-notebook/interesting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Q458. Poor Pigs</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q142/</link>
      <pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q142/</guid>
      <description>There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour? Answer this question, and write an algorithm for the general case. General case: If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous bucket within p minutes?</description>
    </item>
    
    <item>
      <title>Q142. Linked List Cycle II</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q1420/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q1420/</guid>
      <description>Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&#39;s next pointer is connected to. Note that pos is not passed as a parameter.</description>
    </item>
    
    <item>
      <title>Q384. Shuffle an Array</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q384/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q384/</guid>
      <description>Shuffle a set of numbers without duplicates. Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to its original configuration [1,2,3]. solution.reset(); // Returns the random shuffling of array [1,2,3]. solution.shuffle(); This is about generating random permutation when we have a random integer generator.</description>
    </item>
    
    <item>
      <title>Q995: Minimum Number of K Consecutive Bit Flips</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q995/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q995/</guid>
      <description>In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2].</description>
    </item>
    
  </channel>
</rss>
