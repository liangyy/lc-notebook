<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home page on LeetCode NoteBook</title>
    <link>https://liangyy.github.io/lc-notebook/</link>
    <description>Recent content in Home page on LeetCode NoteBook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 09 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://liangyy.github.io/lc-notebook/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Q1363. Largest Multiple of Three</title>
      <link>https://liangyy.github.io/lc-notebook/smalltrick/q1363/</link>
      <pubDate>Mon, 09 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/smalltrick/q1363/</guid>
      <description>Given an integer array of digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. Since the answer may not fit in an integer data type, return the answer as a string. If there is no answer return an empty string. Example 1: Input: digits = [8,1,9] Output: &amp;quot;981&amp;quot; Example 2: Input: digits = [8,6,7,1,0] Output: &amp;quot;8760&amp;quot; Example 3: Input: digits = [1] Output: &amp;quot;&amp;quot; Example 4: Input: digits = [0,0,0,0,0,0] Output: &amp;quot;0&amp;quot; Constraints: 1 &amp;lt;= digits.</description>
    </item>
    
    <item>
      <title>Q1283. Find the Smallest Divisor Given a Threshold</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q1283/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q1283/</guid>
      <description>Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).</description>
    </item>
    
    <item>
      <title>Q310. Minimum Height Trees</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q310/</link>
      <pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q310/</guid>
      <description>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.</description>
    </item>
    
    <item>
      <title>Q673. Number of Longest Increasing Subsequence</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q673/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q673/</guid>
      <description>Given an integer array nums, return the number of longest increasing subsequences. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&#39; length is 1, so output 5. Constraints: 0 &amp;lt;= nums.length &amp;lt;= 2000 -106 &amp;lt;= nums[i] &amp;lt;= 106 For this question, my first thought is dynamic programming.</description>
    </item>
    
    <item>
      <title>Q99. Recover Binary Search Tree</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q99/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q99/</guid>
      <description>You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 &amp;gt; 1. Swapping 1 and 3 makes the BST valid.</description>
    </item>
    
    <item>
      <title>Q142. Linked List Cycle II</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q142/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q142/</guid>
      <description>Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&#39;s next pointer is connected to. Note that pos is not passed as a parameter.</description>
    </item>
    
    <item>
      <title>Q316. Remove Duplicate Letters</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q316/</link>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q316/</guid>
      <description>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/ Example 1: Input: s = &amp;quot;bcabc&amp;quot; Output: &amp;quot;abc&amp;quot; Example 2: Input: s = &amp;quot;cbacdcbc&amp;quot; Output: &amp;quot;acdb&amp;quot; Constraints: 1 &amp;lt;= s.length &amp;lt;= 104 s consists of lowercase English letters. I think this question definitely fits into &amp;ldquo;Need to Know&amp;rdquo; category.</description>
    </item>
    
    <item>
      <title>Q384. Shuffle an Array</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q384/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q384/</guid>
      <description>Shuffle a set of numbers without duplicates. Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to its original configuration [1,2,3]. solution.reset(); // Returns the random shuffling of array [1,2,3]. solution.shuffle(); This is about generating random permutation when we have a random integer generator.</description>
    </item>
    
    <item>
      <title>Q459. Repeated Substring Pattern</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q459/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q459/</guid>
      <description>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1: Input: &amp;quot;abab&amp;quot; Output: True Explanation: It&#39;s the substring &amp;quot;ab&amp;quot; twice. Example 2: Input: &amp;quot;aba&amp;quot; Output: False Example 3: Input: &amp;quot;abcabcabcabc&amp;quot; Output: True Explanation: It&#39;s the substring &amp;quot;abc&amp;quot; four times.</description>
    </item>
    
    <item>
      <title>Q600: Non-negative Integers without Consecutive Ones</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q600/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q600/</guid>
      <description>Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation: Here are the non-negative integers &amp;lt;= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.</description>
    </item>
    
    <item>
      <title>Q847. Shortest Path Visiting All Nodes</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q847/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q847/</guid>
      <description>An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</description>
    </item>
    
    <item>
      <title>Q189. Rotate Array</title>
      <link>https://liangyy.github.io/lc-notebook/smalltrick/q189/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/smalltrick/q189/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative. Follow up: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints: 1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Q309: Best Time to Buy and Sell Stock with Cooldown</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q309/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q309/</guid>
      <description>Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>Q337: House Robber III</title>
      <link>https://liangyy.github.io/lc-notebook/smalltrick/q337/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/smalltrick/q337/</guid>
      <description>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;quot;root.&amp;quot; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;quot;all houses in this place forms a binary tree&amp;quot;. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Q995: Minimum Number of K Consecutive Bit Flips</title>
      <link>https://liangyy.github.io/lc-notebook/interesting/q995/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/interesting/q995/</guid>
      <description>In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2].</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>https://liangyy.github.io/lc-notebook/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/about/</guid>
      <description>Hugo is a static site engine written in Go.
It makes use of a variety of open source projects including:
 Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.</description>
    </item>
    
    <item>
      <title>Q307. Range Sum Query - Mutable</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q307/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q307/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Q94. Binary Tree Inorder Traversal</title>
      <link>https://liangyy.github.io/lc-notebook/needtoknow/q94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liangyy.github.io/lc-notebook/needtoknow/q94/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
