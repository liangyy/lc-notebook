[{"content":"Some interesting questions.\nI didn\u0026amp;rsquo;t get it but it is interesting.\n","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"2d3174f210d2886afc0d0eb0bb87c255","permalink":"https://liangyy.github.io/lc-notebook/interesting/","publishdate":"2020-10-09T00:00:00Z","title":"Interesting"},{"content":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026#39;s next pointer is connected to. Note that pos is not passed as a parameter. Notice that you should not modify the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 104]. -105 \u0026amp;lt;= Node.val \u0026amp;lt;= 105 pos is -1 or a valid index in the linked-list. This question is quite challenging for me. I did not come up with the idea .. It turns out that we need two pointers to do the trick. I feel that it is somewhat clever and fit the question just well.\nTo solve the question essentially contains two steps:\n Identify if there is loop. If so, identify the node which has two incoming edges.  The first step is \u0026amp;ldquo;Q141. Linked List Cycle\u0026amp;rdquo;. (If I was given this question, I could not get it, either ..) The trick is to use two pointers which have different speeds. Specifically, let\u0026amp;rsquo;s have two pointers, slow and fast, where fast goes twice as fast as slow.\nThen, we can image that:\n If there is no loop, fast will hit None eventually and we can terminate safely. If there is loop, fast and slow will meet eventually. And suppose the algorithm goes for n steps when they meet, then fast goes n steps more than slow and n is actually the length of (or …","date":1603756800,"description":"","lastmod":"2020-10-27T00:00:00Z","objectID":"a2231bc93367df39c1054ef737f2579f","permalink":"https://liangyy.github.io/lc-notebook/interesting/q142/","publishdate":"2020-10-27T00:00:00Z","title":"Q142. Linked List Cycle II"},{"content":"Shuffle a set of numbers without duplicates. Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to its original configuration [1,2,3]. solution.reset(); // Returns the random shuffling of array [1,2,3]. solution.shuffle(); This is about generating random permutation when we have a random integer generator.\nAs it sounds, it is not a typical question but definitely something need to know (here I\u0026amp;rsquo;d rather treat it as something good to know).\nThe solution mentions about Fisher-Yates shuffle (which I\u0026amp;rsquo;m not aware before). The approach is straight forward. Suppose we have N integers, the way to generate a random permutation is:\n For jth position, randomly select one from the remaining (N - j + 1) elements. Do it from position 1 to N.  Why it works? Since for permutation n1, \u0026amp;hellip;, nN,\n n1 has 1 / N probability to be positioned at the first position. n2 has 1 / (N - 1) probability to be positioned at the second position. And so on so forth.  So, n1, \u0026amp;hellip;, nN has 1 / N! probability to be drawn. As there are N! number of permutations, each one of them has the same probability to be drawn.\nOK, the important thing is how to implement it efficiently. For a naive implementation, we need to remove the elements that have been selected. It requires $O(N)$ time complexity at each draw and overall it needs $O(N^2)$ time complexity to obtain a permutation.\nHow to improve? All we need is to maintain the subarray containing the unselected elements. This can be done by swapping. Specifically, at position j (the place we want to fill in), suppose subarray nums[j:] contains the unselected elements, we can swap the selected one (with index j + random_idx where random_idx is among 0:(N-j)) and the current jth element. By doing so, the new subarray nums[j+1:] …","date":1602374400,"description":"","lastmod":"2020-10-11T00:00:00Z","objectID":"53e65867aa21d15701444a3c8af1894b","permalink":"https://liangyy.github.io/lc-notebook/interesting/q384/","publishdate":"2020-10-11T00:00:00Z","title":"Q384. Shuffle an Array"},{"content":"In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2]. Example 2: Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can\u0026#39;t make the array become [1,1,1]. Example 3: Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1] The solution suggests to do it greedily. By \u0026amp;ldquo;greedy\u0026amp;rdquo;, it means that we could start from the very left and if there is 0 at position i, we apply K-bit operation for the subarray A[i], ..., A[i + K - 1]. And then, the solution discusses about how to do this in an efficient way. For the latter, it utilizes the trick constantly appearing in handling interval. From my word, we can define an interval by marking up the start and end position. And we read the interval via scanning the list and at each iteration, we grab the information from the previous position and the mark of the current position to know if the current point is in any interval.\nOK, the above discussion is very hand-waving in two senses:\n Why the greedy approach works? How exactly is it implemented?  First thing first: Why greedy? Note that the only mattering thing is the number of operations on each position. So, if we can see that the order of the operations does not matter. Consider the very left entry, only 0 or 1 operation makes sense, any more operations are not necessary (they cancel out themselves). Then, we can go the next entry and do the same reasoning given that we\u0026amp;rsquo;ve know that it has been applied 0 or 1 operation from …","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"6c6f6f30e93803a9b09ceab2360e3059","permalink":"https://liangyy.github.io/lc-notebook/interesting/q995/","publishdate":"2020-10-09T00:00:00Z","title":"Q995: Minimum Number of K Consecutive Bit Flips"},{"content":"We need to know these tricks well.\n","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"607b2ad3adb8e5aa905cbf3b68b65fc7","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/","publishdate":"2020-10-10T00:00:00Z","title":"Need to Know"},{"content":"Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer. Example 1: Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). Example 2: Input: nums = [2,3,5,7,11], threshold = 11 Output: 3 Example 3: Input: nums = [19], threshold = 5 Output: 4 Constraints: 1 \u0026amp;lt;= nums.length \u0026amp;lt;= 5 * 10^4 1 \u0026amp;lt;= nums[i] \u0026amp;lt;= 10^6 nums.length \u0026amp;lt;= threshold \u0026amp;lt;= 10^6 At the very beginning, I was thinking about a fast way to calculate the answer since it is about dividing something. The annoying thing is about how to handle these +1 or +0 situation for rounding.\nWith some effort, I found it non-trivial to handle. The difficulty is that I could not find a good way to keep track of whether a divisor will give +1 or +0 for a number in the list.\nIt turns out that the solution is a direct extension of the brute force solution. For brute force, we start from divisor = 1 and keep increasing the divisor until it gives the result smaller than the threshold.\nThe improvement is to use binary search. Note that we know that the solution is between 1 and max(nums). Let\u0026amp;rsquo;s keep the left boundary not passing the threshold. And keep right boundary passing the threshold. The goal is to have the right boundary going down.\nThe Python submission.\nclass Solution: def smallestDivisor(self, nums: List[int], threshold: int) -\u0026amp;gt; int: if sum(nums) \u0026amp;lt;= threshold: return 1 return self.bin_search(nums, 1, max(nums), threshold) def eval(self, nums, ii): res …","date":1604707200,"description":"","lastmod":"2020-11-07T00:00:00Z","objectID":"e73025f3631f6996d7915c400b506dfb","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q1283/","publishdate":"2020-11-07T00:00:00Z","title":"Q1283. Find the Smallest Divisor Given a Threshold"},{"content":"","date":-62135596800,"description":"","objectID":"591c2efcb095e153d168801dd3b05d35","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q307/","title":"Q307. Range Sum Query - Mutable"},{"content":"Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] At first, I thought about dynamic programming with the thought that:\n For the first j days, the best solution is among: 1. the first j-1 day and do nothing at j; 2. bug and sell at kth and jth day, and doing something at the first k-2 days (we need k-2 since we cannot do anything at k-1th day in order to buy at kth day).\n With this idea, it yields an DP algorithm with time complexity $O(N^2)$ since at each time I need to traverse to get the choice of k.\nOK, how to improve? It can be done in linear time ..\nHow about maintaining some finer information? At jth day, all I need to decide is whether I want to buy, sell, or cool down (I have to cool down). The rule is (from previous day to current day):\n sell -\u0026amp;gt; cool down; buy -\u0026amp;gt; sell; cool down -\u0026amp;gt; buy  Of course, we can do nothing as well. So, essentially, we have 2 choices: 1. to sell (if have share); 2. to have share (by buying or not selling). But we need to know if we could buy so we also need to know the status about not having a share. So, we maintain three events: 1. sell at j day; 2. have a share at j day; 3. not have a share at j day (not by selling). And taking DP in, we want to maintain the best solution where the last state is one of the three respectively.\nSo, the pseudocode is:\nbest_sell = [ 0 ] * len(prices) best_hold = [ 0 ] * len(prices) best_noshare = [ 0 ] * len(prices) # initialize best_sell[0] = -float(\u0026#39;inf\u0026#39;) best_hold[0] = …","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"513fd6d4af1853064d434bf44bf5d808","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q309/","publishdate":"2020-10-10T00:00:00Z","title":"Q309: Best Time to Buy and Sell Stock with Cooldown"},{"content":"A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs). Return a list of all MHTs\u0026#39; root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1: Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. Example 2: Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] Example 3: Input: n = 1, edges = [] Output: [0] Example 4: Input: n = 2, edges = [[0,1]] Output: [0,1] Constraints: 1 \u0026amp;lt;= n \u0026amp;lt;= 2 * 104 edges.length == n - 1 0 \u0026amp;lt;= ai, bi \u0026amp;lt; n ai != bi All the pairs (ai, bi) are distinct. The given input is guaranteed to be a tree and there will be no repeated edges. For me, it is super hard to get the idea initially. And the implementation itself is also quite challenging for me. Because of this, I think it is good to write it down for future re-visit.\nThe height of the tree is the maximum depth among all leaves. So, if we want to minimize the height of the tree (to determine where to put the root), we want the depth of all leaves to be as even as possible. To make it even, the actual problem focuses on the longest path between two leaves. The root has to locate on this path otherwise, the height should be determined by one of the two leaves of this path anyway and we can always reduce the depth to these two leaves …","date":1604534400,"description":"","lastmod":"2020-11-05T00:00:00Z","objectID":"f77b6d41a7e7dd448a6939e56544fb05","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q310/","publishdate":"2020-11-05T00:00:00Z","title":"Q310. Minimum Height Trees"},{"content":"Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/ Example 1: Input: s = \u0026amp;quot;bcabc\u0026amp;quot; Output: \u0026amp;quot;abc\u0026amp;quot; Example 2: Input: s = \u0026amp;quot;cbacdcbc\u0026amp;quot; Output: \u0026amp;quot;acdb\u0026amp;quot; Constraints: 1 \u0026amp;lt;= s.length \u0026amp;lt;= 104 s consists of lowercase English letters. I think this question definitely fits into \u0026amp;ldquo;Need to Know\u0026amp;rdquo; category. It uses clever trick which I did not get it initially.\nIt turns out that we could do this greedily. From left to right, when we get increasing characters in a row, we don\u0026amp;rsquo;t need to do any further thing. But when a small character occurs, we want to start over from the small one if the previous characters re-occur in the subsequent strings. But what if some characters do not occur again? It suggests that they should be at least at the current position or even occur earlier. But since the previous string is increasing, to keep the not re-occurring character at the current position is the best solution.\nOK, let\u0026amp;rsquo;s wrap up the idea above into an algorithm. First we need to know if the character is re-occurring after a position. To do so, we can record the last position of each character. Another detail is that whenever we saw a character that have already occurred in the current string, we safely ignore it since to start over at the new one won\u0026amp;rsquo;t give better solution that the current one.\nSumming up, the algorithm is:\n  At position j, if s[j] is not in the current stack (use a dict to maintain this):\n If s[j] \u0026amp;gt; stack[-1], append s[j] to the end of stack If s[j] \u0026amp;lt; stack[-1] and last_position[stack[-1]] \u0026amp;gt; j, pop the top one in the stack until one of the two conditions s[j] \u0026amp;lt; stack[-1] and last_position[stack[-1]] \u0026amp;gt; j do not hold.    The stack contains …","date":1602460800,"description":"","lastmod":"2020-10-12T00:00:00Z","objectID":"93e2e847497a66818fff9ed1d996bbe3","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q316/","publishdate":"2020-10-12T00:00:00Z","title":"Q316. Remove Duplicate Letters"},{"content":"Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1: Input: \u0026amp;quot;abab\u0026amp;quot; Output: True Explanation: It\u0026#39;s the substring \u0026amp;quot;ab\u0026amp;quot; twice. Example 2: Input: \u0026amp;quot;aba\u0026amp;quot; Output: False Example 3: Input: \u0026amp;quot;abcabcabcabc\u0026amp;quot; Output: True Explanation: It\u0026#39;s the substring \u0026amp;quot;abc\u0026amp;quot; four times. (And the substring \u0026amp;quot;abcabc\u0026amp;quot; twice.) Brute force solution does the job. In short, check all prefixes with length divides len(s).\n","date":1602374400,"description":"","lastmod":"2020-10-11T00:00:00Z","objectID":"2dd0ef2515e10231acb19806db601c57","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q459/","publishdate":"2020-10-11T00:00:00Z","title":"Q459. Repeated Substring Pattern"},{"content":"Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation: Here are the non-negative integers \u0026amp;lt;= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. Let\u0026amp;rsquo;s say the number without consecutive ones is called \u0026amp;ldquo;good number\u0026amp;rdquo;. To count the number of \u0026amp;ldquo;good number\u0026amp;rdquo; with less than or equal to N bits is straight forward. In brief, we can maintain some states like the number of \u0026amp;ldquo;good number\u0026amp;rdquo; with at most j bits that ends with zero or one. With this setting up, we can have some recursion like:\n ngood_end_with_1[j] = ngood_end_with_0[j - 1] ngood_end_with_0[j] = ngood_end_with_1[j - 1] + ngood_end_with_0[j - 1]  OK, then the problem becomes how to count the number of \u0026amp;ldquo;good number\u0026amp;rdquo; \u0026amp;lt;= the target (and it takes me forever to get it right, and this motivates me the write it down ..).\nThe initial idea is simple. Suppose the target is 10000, then we can simply count the \u0026amp;ldquo;good number\u0026amp;rdquo; with at most 4 bits (and add 1 at the end since we need to include 10000 as well). Then for a more complex number like 10100, then we can count 4-bit \u0026amp;ldquo;good number\u0026amp;quot;s and count \u0026amp;ldquo;good number\u0026amp;rdquo; like 100XX which means counting 2-bit \u0026amp;ldquo;good number\u0026amp;rdquo;. Still, we need extra 1 to count 10100. But what if we encounter 10110? Besides the 4-bit and 2-bit, we need to consider 1010X, essentially 1-bit. And no need to add extra 1 since we don\u0026amp;rsquo;t want to count 10110.\nSo, we can scan from the leading \u0026amp;ldquo;1\u0026amp;rdquo; and count the n-bit \u0026amp;ldquo;good number\u0026amp;rdquo; and move to the next \u0026amp;ldquo;1\u0026amp;rdquo;. If the \u0026amp;ldquo;1\u0026amp;rdquo; is right after another \u0026amp;ldquo;1\u0026amp;rdquo;, we count the n-bit and then we can return since for number 11\u0026amp;hellip; then …","date":1602374400,"description":"","lastmod":"2020-10-11T00:00:00Z","objectID":"68362603e66a89a32bda3de027796169","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q600/","publishdate":"2020-10-11T00:00:00Z","title":"Q600: Non-negative Integers without Consecutive Ones"},{"content":"Given an integer array nums, return the number of longest increasing subsequences. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences\u0026#39; length is 1, so output 5. Constraints: 0 \u0026amp;lt;= nums.length \u0026amp;lt;= 2000 -106 \u0026amp;lt;= nums[i] \u0026amp;lt;= 106 For this question, my first thought is dynamic programming. Essentially, we want to maintain the solution to the following problem: the number of the longest subsequence of the prefix nums[1:k] which contains nums[k]. Also, we also want to keep the length of such longest subsequence.\nThe subproblem for nums[1:k] can be easily derived from all the previous subproblems (for smaller prefixes). Suppose for the subproblem, the number of longest subsequence is called n_ls and the length of such sequence is l_ls.\n If there exists nums[j] \u0026amp;lt; nums[k] for any j \u0026amp;lt; k, then find the j_max among the js\u0026#39; with longest length subsequence and update n_ls[k] = sum(n_ls[j_max]) and l_ls[k] = l_ls[j_max]. If there is no such j, n_ls[k] = 1 and l_ls[k] = 1.  The Python submission is.\nclass Solution: def findNumberOfLIS(self, nums: List[int]) -\u0026amp;gt; int: # dp: dp[i] record the number of longest subsequences ends at i and the length of the subseq # dp[i] = sum(dp[k][0]), for k such that k \u0026amp;lt; i and nums[k] \u0026amp;lt;= nums[i] and max k dp[k][1] if no k, then dp[i] = 1, 1 # return sum(dp[k][0]) for max k of dp[k][1] # complexity O(n^2) n = len(nums) if n \u0026amp;lt;= 1: return n dp = [ [0, 0] for i in range(n) ] dp[0] = [1, 1] for i in range(1, n): max_l = 0 good_k = [] for j in range(i): if nums[j] \u0026amp;lt; nums[i]: if max_l \u0026amp;lt; dp[j][1]: good_k = [ j ] max_l = max(max_l, dp[j][1]) elif max_l == dp[j][1]: good_k.append(j) if len(good_k) == 0: dp[i] = [1, 1] else: dp[i][1] = max_l + 1 for k in good_k: dp[i][0] += dp[k][0] max_l = 0 res = 0 # …","date":1604102400,"description":"","lastmod":"2020-10-31T00:00:00Z","objectID":"a361604af1ae432e9e488ce37df42aee","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q673/","publishdate":"2020-10-31T00:00:00Z","title":"Q673. Number of Longest Increasing Subsequence"},{"content":"An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph. graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. Example 1: Input: [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3] Note: 1 \u0026amp;lt;= graph.length \u0026amp;lt;= 12 0 \u0026amp;lt;= graph[i].length \u0026amp;lt; graph.length I did not get this question and it did look very complicated to me. Before going to the solution, I should say that there are some general ideas to wear before thinking about a question involving shortest path.\n Shortest path from a start to an end (Dijkstra\u0026amp;rsquo;s). Shortest path among all pairs of nodes (Floyd–Warshall).  For an unweighted graph, the Dijkstra\u0026amp;rsquo;s algorithm is very similar to a BFS traverse.\nFor this question, the essential idea is to construct the state properly.\nFirst of all, what could be a brute force approach? We explore the nodes randomly and we are free to go back and forth. But the problem is that we may get stuck by loop. So, we need to realize that we are in a loop. The trick to realize it is by constructing the state properly. Let\u0026amp;rsquo;s say the state is the current explored notes and the current position. The edges that connect the state space are defined implicitly by the edges of the graph. In other word, at the current state, we can move to another state by exploring the neighbors of the current node (at the position).\nOK, the initial state would be (explored node set = (node i), node i) and we can do BFS until hitting the state with explored node set = all nodes.\nIn terms of the data structure, we can use a series of binary numbers to represent if the nth node has been explored (the way to …","date":1602374400,"description":"","lastmod":"2020-10-11T00:00:00Z","objectID":"b7ed2b8abfd2aaa840ced90735263507","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q847/","publishdate":"2020-10-11T00:00:00Z","title":"Q847. Shortest Path Visiting All Nodes"},{"content":"","date":-62135596800,"description":"","objectID":"7d2394f75fff21fcc5620e1a0871f3c4","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q94/","title":"Q94. Binary Tree Inorder Traversal"},{"content":"You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 \u0026amp;gt; 1. Swapping 1 and 3 makes the BST valid. Example 2: Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 \u0026amp;lt; 3. Swapping 2 and 3 makes the BST valid. Constraints: The number of nodes in the tree is in the range [2, 1000]. -231 \u0026amp;lt;= Node.val \u0026amp;lt;= 231 - 1 Here I focus on the solution with $O(N)$ space complexity, which definitely falls into the category of \u0026amp;ldquo;need to know\u0026amp;rdquo;.\nThe whole point is about performing the in-order traverse of the BST. If the BST is valid, the in-order traverse will result in an ascending order sequence. Whereas, if the BST is not valid, the resulting sequence won\u0026amp;rsquo;t be ascending and as stated in the question, it should be fixed by a simple swap. For instance, if we have 0, 1, 4, 3, 2, 5, 6, we can easily see that 4 and 2 are swapped. This means that suppose we have the sequence, we could identify the pair to swap by extracting all the pairs with wrong order and extract the first and the last number of these pairs.\nSo, all the point of this question is to have in-order traverse in mind clearly. To have it briefly reviewed, the in-order traverse procedure is:\n Maintain a stack of node to visit. At a current node, push itself to the to-visit stack and go to its left child until there exists no more left child. Go to the top of the stack, visit that node and set its right child as current node.  The Python submission is.\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # …","date":1604102400,"description":"","lastmod":"2020-10-31T00:00:00Z","objectID":"4b95fd9f0f93ab53b8609a552aa12b7a","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q99/","publishdate":"2020-10-31T00:00:00Z","title":"Q99. Recover Binary Search Tree"},{"content":"Use it when seeing needs and fits.\n","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"4494ff8e405104b0682a0c124f86b18d","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/","publishdate":"2020-10-10T00:00:00Z","title":"Small Trick"},{"content":"Given an integer array of digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. Since the answer may not fit in an integer data type, return the answer as a string. If there is no answer return an empty string. Example 1: Input: digits = [8,1,9] Output: \u0026amp;quot;981\u0026amp;quot; Example 2: Input: digits = [8,6,7,1,0] Output: \u0026amp;quot;8760\u0026amp;quot; Example 3: Input: digits = [1] Output: \u0026amp;quot;\u0026amp;quot; Example 4: Input: digits = [0,0,0,0,0,0] Output: \u0026amp;quot;0\u0026amp;quot; Constraints: 1 \u0026amp;lt;= digits.length \u0026amp;lt;= 10^4 0 \u0026amp;lt;= digits[i] \u0026amp;lt;= 9 The returning answer must not contain unnecessary leading zeros. At the beginning, it is easy to get the idea that this problem should be solved by dynamic programming. And the answer will be constantly built upon previous problem.\nThe key observation is that the number that divides 3 have all digits summation dividing 3. So, we can easily build the current solution from the max number with sum modulo 3 equals k (k = 0, 1, 2). Let the dp[k] indicate the solution with digits sum modulo 3 equals k. For the ith number, the update rule for dp[k] is:\n Compare dp[k] and dp[ (k - digits[i]) % 3 ] with digits[i] being added.  We should update dp[k] to the one that gives rise to a bigger number.\nOK, here comes to the real tricky part. For me, I did not get the right data structure to use to make this comparison efficient enough (we need to do it in $O(1)$).\nI was thinking about a sorted list, which is hard to update and maintain. It turns out that we should use an 10-element array with each element representing the count of one digits.\nThe Python submission is as follow.\nclass Solution: def largestMultipleOfThree(self, digits: List[int]) -\u0026amp;gt; str: if len(digits) == 0: return \u0026#39;\u0026#39; soln = [ [ 0 for i in range(10) ] for j in range(3) ] for d in digits: new_soln = [ [] for j in range(3) ] for i in range(3): j = (d + i) % 3 tmp = [ 0 for i_ in range(10) ] if sum(soln[i]) \u0026amp;gt; 0 or i == 0: tmp = soln[i][:] …","date":1604880000,"description":"","lastmod":"2020-11-09T00:00:00Z","objectID":"3dd1df2d41aa288ded76df2b3c3dbea8","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/q1363/","publishdate":"2020-11-09T00:00:00Z","title":"Q1363. Largest Multiple of Three"},{"content":"Given an array, rotate the array to the right by k steps, where k is non-negative. Follow up: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints: 1 \u0026amp;lt;= nums.length \u0026amp;lt;= 2 * 104 -231 \u0026amp;lt;= nums[i] \u0026amp;lt;= 231 - 1 0 \u0026amp;lt;= k \u0026amp;lt;= 105 The idea is simple, just to keep updating by jumping to new position i \u0026amp;lt;- (i + k) % n. Some minor thing is that we can do k = k % n before getting started. And if k = 0, we can immediately return without doing anything.\nThe difficulty for me is that I know there will be multiple cycles but it is really hard to know beforehand how many cycles are needed. I was thinking about using a for loop to go through all these cycles in order.\nBut, such difficulty can be avoided. Or, we don\u0026amp;rsquo;t need to know the number of cycles beforehand. Instead, we can keep track of the number of positions that have been updated. And whenever we ends one cycle, we can safely go to i \u0026amp;lt;- i + 1 and start a new cycle since we can be sure that it has not been visited. Why? If the next position has been visited by one of the previous ones, no matter which one, we know that the same thing will happen for the next next position as well (since all the previous cycle starts have been visited). Following this, we will have all positions being visited already. So, whenever there is unvisited position, the next position has to be unvisited.\nTo make this idea more generally, essentially, the strategy here is to come up with an order of visiting (no duplicated visit …","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"48a5f0db5a8d48dfcc41cc477408ded6","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/q189/","publishdate":"2020-10-10T00:00:00Z","title":"Q189. Rotate Array"},{"content":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \u0026amp;quot;root.\u0026amp;quot; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \u0026amp;quot;all houses in this place forms a binary tree\u0026amp;quot;. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. As in tree structure, we can say that the problem for the tree can be divided into problems of the left and right subtrees and once we get these subproblems out, we could merge them somehow to get the answer for the full tree.\nIt fits well for tree structure since we don\u0026amp;rsquo;t need to worry about the issue of duplicated work. The root could either be robbed or not and the solution takes the better one among the two.\nno_rob_val(node) = max(rob_val(node.left), no_rob_val(node.left)) + max(rob_val(node.right), no_rob_val(node.right)) rob_val(node) = node.val + no_rob_val(node.left) + no_rob_val(node.right) From here, the first thought is to solve rob_val and no_rob_val separately. But the problem is that rob_val(node) and no_rob_val(node) generates duplicated recursion. More specifically, they ask for no_rob_val(node.left) and no_rob_val(node.right) twice.\nOK, here comes the trick. We can solve the rob_val and no_rob_val in one calculation, simply we calculate no_rob_val(node.left) and no_rob_val(node.right) once and apply to both no_rob_val(node) and rob_val(node).\nSo, it becomes:\nno_rob_val_left, rob_val_left = soln(node.left) no_rob_val_right, rob_val_right = soln(node.right) no_rob_val = …","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"e5038056b198d7292da2c91b0f8846dc","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/q337/","publishdate":"2020-10-10T00:00:00Z","title":"Q337: House Robber III"},{"content":"Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: True Note: All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order. There are many ways to solve this problem but I found the solution provided by LeetCode interesting and clever so that I want to write it down here. Before getting into their trick, let me state what I did and what makes this problem a bit challenging.\nI ended up calculating all the pairwise distances between all pairs of points. And then, I check if these distances follow what we would expect from a square. In short, we check two things:\n If there is only two values of distances. If the smaller distance has 8 instances and the larger one has 4 instance.  If these are correct, we can say it is square. The reason is as follow. Since these smaller distances can only come from the sides A-B, B-C, C-D, D-A. We can check that other cases are impossible. So, it can only be diamond. And the longer distances are all the same value, so the diamond has to be square.\nThe Python submission.\nclass Solution: def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -\u0026amp;gt; bool: pp = [p1, p2, p3, p4] ll = [] for q1 in pp: for q2 in pp: if q1 == q2: continue ll.append(self.dist(q1, q2)) if len(ll) \u0026amp;lt; 12: return False min_l = min(ll) max_l = max(ll) if min_l == max_l: return False n_min = 0 n_max = 0 for l in ll: if l == min_l: n_min += 1 if l == max_l: n_max += 1 if n_min == 8 and n_max == 4: return True else: return False def dist(self, s1, s2): x1, y1 = s1 x2, y2 = s2 return (x1 - x2) ** 2 + (y1 - y2) ** 2 OK, next, let\u0026amp;rsquo;s talk about the trick I learned on LeetCode solution. When approaching this …","date":1605052800,"description":"","lastmod":"2020-11-11T00:00:00Z","objectID":"abaaed56d2c12228548bb13293a4be1d","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/q593/","publishdate":"2020-11-11T00:00:00Z","title":"Q593. Valid Square"},{"content":"My wishlist.\n on segment tree on BST inorder traverse  ","date":1604102400,"description":"","lastmod":"2020-10-31T00:00:00Z","objectID":"5d3e79f09a7c0aac955dcc6b9cb3b1e2","permalink":"https://liangyy.github.io/lc-notebook/todo/","publishdate":"2020-10-31T00:00:00Z","title":"To-do list"},{"content":"About This is my LeetCode notebook.\nIt is by no mean systematic but a playground recording what I learned and felt interesting and worth to write down. As time passes, everything goes away but wish the joy might stay.\n","date":1602201600,"description":"Home page","lastmod":"2020-10-09T00:00:00Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://liangyy.github.io/lc-notebook/","publishdate":"2020-10-09T00:00:00Z","title":"Home page"},{"content":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n","date":1397001600,"description":"","lastmod":"2014-04-09T00:00:00Z","objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://liangyy.github.io/lc-notebook/about/","publishdate":"2014-04-09T00:00:00Z","title":"About Hugo"}]