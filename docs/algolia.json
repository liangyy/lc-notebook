[{"content":"Some interesting questions.\nI didn\u0026amp;rsquo;t get it but it is interesting.\n","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"2d3174f210d2886afc0d0eb0bb87c255","permalink":"https://liangyy.github.io/lc-notebook/interesting/","publishdate":"2020-10-09T00:00:00Z","title":"Interesting"},{"content":"In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2]. Example 2: Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can\u0026#39;t make the array become [1,1,1]. Example 3: Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1] The solution suggests to do it greedily. By \u0026amp;ldquo;greedy\u0026amp;rdquo;, it means that we could start from the very left and if there is 0 at position i, we apply K-bit operation for the subarray A[i], ..., A[i + K - 1]. And then, the solution discusses about how to do this in an efficient way. For the latter, it utilizes the trick constantly appearing in handling interval. From my word, we can define an interval by marking up the start and end position. And we read the interval via scanning the list and at each iteration, we grab the information from the previous position and the mark of the current position to know if the current point is in any interval.\nOK, the above discussion is very hand-waving in two senses:\n Why the greedy approach works? How exactly is it implemented?  First thing first: Why greedy? Note that the only mattering thing is the number of operations on each position. So, if we can see that the order of the operations does not matter. Consider the very left entry, only 0 or 1 operation makes sense, any more operations are not necessary (they cancel out themselves). Then, we can go the next entry and do the same reasoning given that we\u0026amp;rsquo;ve know that it has been applied 0 or 1 operation from â€¦","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"6c6f6f30e93803a9b09ceab2360e3059","permalink":"https://liangyy.github.io/lc-notebook/interesting/q995/","publishdate":"2020-10-09T00:00:00Z","title":"Q995: Minimum Number of K Consecutive Bit Flips"},{"content":"About This is my LeetCode notebook.\nIt is by no mean systematic but a playground recording what I learned and felt interesting and worth to write down. As time passes, everything goes away but wish the joy might stay.\n","date":1602201600,"description":"Home page","lastmod":"2020-10-09T00:00:00Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://liangyy.github.io/lc-notebook/","publishdate":"2020-10-09T00:00:00Z","title":"Home page"},{"content":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n","date":1397001600,"description":"","lastmod":"2014-04-09T00:00:00Z","objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://liangyy.github.io/lc-notebook/about/","publishdate":"2014-04-09T00:00:00Z","title":"About Hugo"}]