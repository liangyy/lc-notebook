[{"content":"Some interesting questions.\nI didn\u0026amp;rsquo;t get it but it is interesting.\n","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"2d3174f210d2886afc0d0eb0bb87c255","permalink":"https://liangyy.github.io/lc-notebook/interesting/","publishdate":"2020-10-09T00:00:00Z","title":"Interesting"},{"content":"In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. Example 1: Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2]. Example 2: Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can\u0026#39;t make the array become [1,1,1]. Example 3: Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1] The solution suggests to do it greedily. By \u0026amp;ldquo;greedy\u0026amp;rdquo;, it means that we could start from the very left and if there is 0 at position i, we apply K-bit operation for the subarray A[i], ..., A[i + K - 1]. And then, the solution discusses about how to do this in an efficient way. For the latter, it utilizes the trick constantly appearing in handling interval. From my word, we can define an interval by marking up the start and end position. And we read the interval via scanning the list and at each iteration, we grab the information from the previous position and the mark of the current position to know if the current point is in any interval.\nOK, the above discussion is very hand-waving in two senses:\n Why the greedy approach works? How exactly is it implemented?  First thing first: Why greedy? Note that the only mattering thing is the number of operations on each position. So, if we can see that the order of the operations does not matter. Consider the very left entry, only 0 or 1 operation makes sense, any more operations are not necessary (they cancel out themselves). Then, we can go the next entry and do the same reasoning given that we\u0026amp;rsquo;ve know that it has been applied 0 or 1 operation from …","date":1602201600,"description":"","lastmod":"2020-10-09T00:00:00Z","objectID":"6c6f6f30e93803a9b09ceab2360e3059","permalink":"https://liangyy.github.io/lc-notebook/interesting/q995/","publishdate":"2020-10-09T00:00:00Z","title":"Q995: Minimum Number of K Consecutive Bit Flips"},{"content":"We need to know these tricks well.\n","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"607b2ad3adb8e5aa905cbf3b68b65fc7","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/","publishdate":"2020-10-10T00:00:00Z","title":"Need to Know"},{"content":"Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] At first, I thought about dynamic programming with the thought that:\n For the first j days, the best solution is among: 1. the first j-1 day and do nothing at j; 2. bug and sell at kth and jth day, and doing something at the first k-2 days (we need k-2 since we cannot do anything at k-1th day in order to buy at kth day).\n With this idea, it yields an DP algorithm with time complexity $O(N^2)$ since at each time I need to traverse to get the choice of k.\nOK, how to improve? It can be done in linear time ..\nHow about maintaining some finer information? At jth day, all I need to decide is whether I want to buy, sell, or cool down (I have to cool down). The rule is (from previous day to current day):\n sell -\u0026amp;gt; cool down; buy -\u0026amp;gt; sell; cool down -\u0026amp;gt; buy  Of course, we can do nothing as well. So, essentially, we have 2 choices: 1. to sell (if have share); 2. to have share (by buying or not selling). But we need to know if we could buy so we also need to know the status about not having a share. So, we maintain three events: 1. sell at j day; 2. have a share at j day; 3. not have a share at j day (not by selling). And taking DP in, we want to maintain the best solution where the last state is one of the three respectively.\nSo, the pseudocode is:\nbest_sell = [ 0 ] * len(prices) best_hold = [ 0 ] * len(prices) best_noshare = [ 0 ] * len(prices) # initialize best_sell[0] = -float(\u0026#39;inf\u0026#39;) best_hold[0] = …","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"513fd6d4af1853064d434bf44bf5d808","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q309/","publishdate":"2020-10-10T00:00:00Z","title":"Q309: Best Time to Buy and Sell Stock with Cooldown"},{"content":"Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones. Example 1: Input: 5 Output: 5 Explanation: Here are the non-negative integers \u0026amp;lt;= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. Let\u0026amp;rsquo;s say the number without consecutive ones is called \u0026amp;ldquo;good number\u0026amp;rdquo;. To count the number of \u0026amp;ldquo;good number\u0026amp;rdquo; with less than or equal to N bits is straight forward. In brief, we can maintain some states like the number of \u0026amp;ldquo;good number\u0026amp;rdquo; with at most j bits that ends with zero or one. With this setting up, we can have some recursion like:\n ngood_end_with_1[j] = ngood_end_with_0[j - 1] ngood_end_with_0[j] = ngood_end_with_1[j - 1] + ngood_end_with_0[j - 1]  OK, then the problem becomes how to count the number of \u0026amp;ldquo;good number\u0026amp;rdquo; \u0026amp;lt;= the target (and it takes me forever to get it right, and this motivates me the write it down ..).\nThe initial idea is simple. Suppose the target is 10000, then we can simply count the \u0026amp;ldquo;good number\u0026amp;rdquo; with at most 4 bits (and add 1 at the end since we need to include 10000 as well). Then for a more complex number like 10100, then we can count 4-bit \u0026amp;ldquo;good number\u0026amp;quot;s and count \u0026amp;ldquo;good number\u0026amp;rdquo; like 100XX which means counting 2-bit \u0026amp;ldquo;good number\u0026amp;rdquo;. Still, we need extra 1 to count 10100. But what if we encounter 10110? Besides the 4-bit and 2-bit, we need to consider 1010X, essentially 1-bit. And no need to add extra 1 since we don\u0026amp;rsquo;t want to count 10110.\nSo, we can scan from the leading \u0026amp;ldquo;1\u0026amp;rdquo; and count the n-bit \u0026amp;ldquo;good number\u0026amp;rdquo; and move to the next \u0026amp;ldquo;1\u0026amp;rdquo;. If the \u0026amp;ldquo;1\u0026amp;rdquo; is right after another \u0026amp;ldquo;1\u0026amp;rdquo;, we count the n-bit and then we can return since for number 11\u0026amp;hellip; then …","date":1602374400,"description":"","lastmod":"2020-10-11T00:00:00Z","objectID":"68362603e66a89a32bda3de027796169","permalink":"https://liangyy.github.io/lc-notebook/needtoknow/q600/","publishdate":"2020-10-11T00:00:00Z","title":"Q600: Non-negative Integers without Consecutive Ones"},{"content":"Use it when seeing needs and fits.\n","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"4494ff8e405104b0682a0c124f86b18d","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/","publishdate":"2020-10-10T00:00:00Z","title":"Small Trick"},{"content":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \u0026amp;quot;root.\u0026amp;quot; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \u0026amp;quot;all houses in this place forms a binary tree\u0026amp;quot;. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. As in tree structure, we can say that the problem for the tree can be divided into problems of the left and right subtrees and once we get these subproblems out, we could merge them somehow to get the answer for the full tree.\nIt fits well for tree structure since we don\u0026amp;rsquo;t need to worry about the issue of duplicated work. The root could either be robbed or not and the solution takes the better one among the two.\nno_rob_val(node) = max(rob_val(node.left), no_rob_val(node.left)) + max(rob_val(node.right), no_rob_val(node.right)) rob_val(node) = node.val + no_rob_val(node.left) + no_rob_val(node.right) From here, the first thought is to solve rob_val and no_rob_val separately. But the problem is that rob_val(node) and no_rob_val(node) generates duplicated recursion. More specifically, they ask for no_rob_val(node.left) and no_rob_val(node.right) twice.\nOK, here comes the trick. We can solve the rob_val and no_rob_val in one calculation, simply we calculate no_rob_val(node.left) and no_rob_val(node.right) once and apply to both no_rob_val(node) and rob_val(node).\nSo, it becomes:\nno_rob_val_left, rob_val_left = soln(node.left) no_rob_val_right, rob_val_right = soln(node.right) no_rob_val = …","date":1602288000,"description":"","lastmod":"2020-10-10T00:00:00Z","objectID":"e5038056b198d7292da2c91b0f8846dc","permalink":"https://liangyy.github.io/lc-notebook/smalltrick/q337/","publishdate":"2020-10-10T00:00:00Z","title":"Q337: House Robber III"},{"content":"About This is my LeetCode notebook.\nIt is by no mean systematic but a playground recording what I learned and felt interesting and worth to write down. As time passes, everything goes away but wish the joy might stay.\n","date":1602201600,"description":"Home page","lastmod":"2020-10-09T00:00:00Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://liangyy.github.io/lc-notebook/","publishdate":"2020-10-09T00:00:00Z","title":"Home page"},{"content":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n","date":1397001600,"description":"","lastmod":"2014-04-09T00:00:00Z","objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://liangyy.github.io/lc-notebook/about/","publishdate":"2014-04-09T00:00:00Z","title":"About Hugo"}]